### Task3（2天）(截止时间：3月6日晚22:00)
#### 排序

* 实现归并排序

**归并排序**（Merge）是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。

归并排序算法稳定，数组需要O(n)的额外空间，链表需要O(log(n))的额外空间，时间复杂度为O(nlog(n))，算法不是自适应的，不需要对数据的随机读取。

**工作原理：**

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针达到序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾

**代码实现：**

```
public class MergeSortTest {
 
	public static void main(String[] args) {
		int[] data = new int[] { 5, 3, 6, 2, 1, 9, 4, 8, 7 };
		print(data);
		mergeSort(data);
		System.out.println("排序后的数组：");
		print(data);
	}
 
	public static void mergeSort(int[] data) {
		sort(data, 0, data.length - 1);
	}
 
	public static void sort(int[] data, int left, int right) {
		if (left >= right)
			return;
		// 找出中间索引
		int center = (left + right) / 2;
		// 对左边数组进行递归
		sort(data, left, center);
		// 对右边数组进行递归
		sort(data, center + 1, right);
		// 合并
		merge(data, left, center, right);
		print(data);
	}
 
	/**
	 * 将两个数组进行归并，归并前面2个数组已有序，归并后依然有序
	 * 
	 * @param data
	 *            数组对象
	 * @param left
	 *            左数组的第一个元素的索引
	 * @param center
	 *            左数组的最后一个元素的索引，center+1是右数组第一个元素的索引
	 * @param right
	 *            右数组最后一个元素的索引
	 */
	public static void merge(int[] data, int left, int center, int right) {
		// 临时数组
		int[] tmpArr = new int[data.length];
		// 右数组第一个元素索引
		int mid = center + 1;
		// third 记录临时数组的索引
		int third = left;
		// 缓存左数组第一个元素的索引
		int tmp = left;
		while (left <= center && mid <= right) {
			// 从两个数组中取出最小的放入临时数组
			if (data[left] <= data[mid]) {
				tmpArr[third++] = data[left++];
			} else {
				tmpArr[third++] = data[mid++];
			}
		}
		// 剩余部分依次放入临时数组（实际上两个while只会执行其中一个）
		while (mid <= right) {
			tmpArr[third++] = data[mid++];
		}
		while (left <= center) {
			tmpArr[third++] = data[left++];
		}
		// 将临时数组中的内容拷贝回原数组中
		// （原left-right范围的内容被复制回原数组）
		while (tmp <= right) {
			data[tmp] = tmpArr[tmp++];
		}
	}
 
	public static void print(int[] data) {
		for (int i = 0; i < data.length; i++) {
			System.out.print(data[i] + "\t");
		}
		System.out.println();
	}
}
```

**输出结果：**

```
5	3	6	2	1	9	4	8	7	
3	5	6	2	1	9	4	8	7	
3	5	6	2	1	9	4	8	7	
3	5	6	1	2	9	4	8	7	
1	2	3	5	6	9	4	8	7	
1	2	3	5	6	4	9	8	7	
1	2	3	5	6	4	9	7	8	
1	2	3	5	6	4	7	8	9	
1	2	3	4	5	6	7	8	9	
排序后的数组：
1	2	3	4	5	6	7	8	9
```

* 快速排序

**算法概念**

快速排序（Quicksort）是对冒泡排序的一种改进。由C.A.R.Hoare在1962年提出。

**算法思想**

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

**实现思路**

1. 以第一个关键字`K1`为控制字，将`[K1,K2,…,Kn]`分成两个子区，使左区所有关键字小于等于`K1`，右区所有关键字大于等于`K1`，最后控制字居两个子区中间的适当位置。在子区内数据尚处于无序状态。 
2. 把左区作为一个整体，用①的步骤进行处理，右区进行相同的处理。（即递归）
3. 重复第1、2步，直到左区处理完毕。

**实现代码**

```
void quicksort(int a[], int left,int right)
{
	int i,j,t,temp;
	if(left>right)
		return;

	temp=a[left]; //temp中存的就是基准数
	i=left;
	j=right;
	while(i!=j)
	{
		//顺序很重要，要先从右边开始找
		while(a[j]>=temp && i<j)
			j--;
		//再找右边的
		while(a[i]<=temp && i<j)
			i++;
		//交换两个数在数组中的位置
		if(i<j)
		{
			t=a[i];
			a[i]=a[j];
			a[j]=t;
		}
	}
	//最终将基准数归位
	a[left]=a[i];
	a[i]=temp;

	quicksort(a, left,i-1);//继续处理左边的，这里是一个递归的过程
	quicksort(a, i+1,right);//继续处理右边的 ，这里是一个递归的过程
}
```

* 插入排序

**基本思想**

**关键**：在前面已经排好序的序列中找到合适的插入位置

**步骤**：

1. 从第一个元素开始，该元素可以认为已经排好序。
2. 取出下一个元素，在已经排好序的元素序列中从后往前扫描进行比较。
3. 如果该元素(已排序) 大于新元素，则将该元素移到下一位置。
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。
5. 将新元素插入到该位置后面。
6. 重复步骤2~5

**图示：**

![插入排序示例](../resources/programming-task3-insertionsort.gif)

**注意：**设置变量t很重要，它记住了待插入的元素的值，元素移动的时候被覆盖了也没关系。

**实现代码**

```
public class InsertSort {
 
	public static void main(String[] args) {
		int[] arr = { 6, 5, 3, 1, 8, 7, 2, 4 };
		System.out.println("排序之前：");
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
 
		// 直接插入排序
		insertSort(arr);
 
		System.out.println();
		System.out.println("排序之后：");
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
	}
 
	/**
	 * 直接插入排序
	 */
	private static void insertSort(int[] arr) {
		int j; // 已排序列表下标
		int t; // 待排序元素
		for (int i = 1; i < arr.length; i++) {
			if (arr[i] < arr[i - 1]) { 
				t = arr[i]; // 赋值给待排序元素
				for (j = i - 1; j >= 0 && arr[j] > t; j--) {
					arr[j + 1] = arr[j]; // 从后往前遍历已排序列表，逐个和待排序元素比较，如果已排序元素较大，则将它后移
				}
				arr[j + 1] = t; // 将待排序元素插入到正确的位置
			}
		}
	}
 
}
```

* 冒泡排序

**原理**：比较两个相邻的元素，将值大的元素交换至右端。

**思路**：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。

第一趟比较完成后，最后一个数一定是数组中最大的一个数，所以第二趟比较的时候最后一个数不参与比较；

第二趟比较完成后，倒数第二个数也一定是数组中第二大的数，所以第三趟比较的时候最后两个数不参与比较；

依次类推，每一趟比较次数-1；

**举例说明**：要排序数组：int[] arr={6,3,8,2,9,1};   

```
第一趟排序：
　　　　第一次排序：6和3比较，6大于3，交换位置：  3  6  8  2  9  1
　　　　第二次排序：6和8比较，6小于8，不交换位置： 3  6  8  2  9  1
　　　　第三次排序：8和2比较，8大于2，交换位置：  3  6  2  8  9  1
　　　　第四次排序：8和9比较，8小于9，不交换位置：3  6  2  8  9  1
　　　　第五次排序：9和1比较：9大于1，交换位置：  3  6  2  8  1  9
　　　　第一趟总共进行了5次比较， 排序结果：      3  6  2  8  1  9
---------------------------------------------------------------------
第二趟排序：
　　　　第一次排序：3和6比较，3小于6，不交换位置：3  6  2  8  1  9
　　　　第二次排序：6和2比较，6大于2，交换位置：  3  2  6  8  1  9
　　　　第三次排序：6和8比较，6大于8，不交换位置：3  2  6  8  1  9
　　　　第四次排序：8和1比较，8大于1，交换位置：  3  2  6  1  8  9
　　　　第二趟总共进行了4次比较， 排序结果：      3  2  6  1  8  9
---------------------------------------------------------------------
第三趟排序：
　　　　第一次排序：3和2比较，3大于2，交换位置：  2  3  6  1  8  9
　　　　第二次排序：3和6比较，3小于6，不交换位置：2  3  6  1  8  9
　　　　第三次排序：6和1比较，6大于1，交换位置：  2  3  1  6  8  9
　　　　第二趟总共进行了3次比较， 排序结果：      2  3  1  6  8  9
---------------------------------------------------------------------
第四趟排序：
　　　　第一次排序：2和3比较，2小于3，不交换位置：2  3  1  6  8  9
　　　　第二次排序：3和1比较，3大于1，交换位置：  2  1  3  6  8  9
　　　　第二趟总共进行了2次比较， 排序结果：      2  1  3  6  8  9
---------------------------------------------------------------------
第五趟排序：
　　　　第一次排序：2和1比较，2大于1，交换位置：  1  2  3  6  8  9
　　　　第二趟总共进行了1次比较， 排序结果：  1  2  3  6  8  9
---------------------------------------------------------------------
最终结果：1  2  3  6  8  9
```

由此可见：`N`个数字要排序完成，总共进行`N-1`趟排序，每`i`趟的排序次数为`(N-i)`次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数，即:

```
for(int i=1;i<arr.length;i++){
    for(int j=1;j<arr.length-i;j++){
    //交换位置
}
```

**冒泡排序的优点**

每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。

**用时间复杂度来说**

1. 如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。
2. 如果很不幸我们的数据是反序的，则需要进行`n-1`趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。

综上所述：冒泡排序总的平均时间复杂度为：O(n2) 。

```
/*
 * 冒泡排序
 */
public class BubbleSort {
　　public static void main(String[] args) {
　　　　int[] arr={6,3,8,2,9,1};
　　　　System.out.println("排序前数组为：");
　　　　for(int num:arr){
　　　　　　System.out.print(num+" ");
　　　　}
　　　　for(int i=0;i<arr.length-1;i++){//外层循环控制排序趟数
　　　　　　for(int j=0;j<arr.length-1-i;j++){//内层循环控制每一趟排序多少次
　　　　　　　　if(arr[j]>arr[j+1]){
　　　　　　　　　　int temp=arr[j];
　　　　　　　　　　arr[j]=arr[j+1];
　　　　　　　　　　arr[j+1]=temp;
　　　　　　　　}
　　　　　　}
　　　　} 
　　　　System.out.println();
　　　　System.out.println("排序后的数组为：");
 　　　　for(int num:arr){
 　　　　　　System.out.print(num+" ");
 　　　　} 
　　}
 }
```

* 选择排序

a) 原理：每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。也就是：每一趟在`n-i+1(i=1，2，…n-1)`个记录中选取关键字最小的记录作为有序序列中第i个记录。基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。（这里只介绍常用的简单选择排序）

b) 简单选择排序的基本思想：给定数组：`int[] arr={里面n个数据}`；第1趟排序，在待排序数据`arr[1]~arr[n]`中选出最小的数据，将它与`arrr[1]`交换；第2趟，在待排序数据`arr[2]~arr[n]`中选出最小的数据，将它与`r[2]`交换；以此类推，第i趟在待排序数据`arr[i]~arr[n]`中选出最小的数据，将它与`r[i]`交换，直到全部排序完成。

c) 举例：数组`int[] arr={5,2,8,4,9,1}`;

```
第一趟排序： 原始数据：5  2  8  4  9  1
最小数据1，把1放在首位，也就是1和5互换位置，
排序结果：1  2  8  4  9  5
-------------------------------------------------------
第二趟排序：
第1以外的数据{2  8  4  9  5}进行比较，2最小，
排序结果：1  2  8  4  9  5
-------------------------------------------------------
第三趟排序：
除1、2以外的数据{8  4  9  5}进行比较，4最小，8和4交换
排序结果：1  2  4  8  9  5
-------------------------------------------------------
第四趟排序：
除第1、2、4以外的其他数据{8  9  5}进行比较，5最小，8和5交换
排序结果：1  2  4  5  9  8
-------------------------------------------------------
第五趟排序：
除第1、2、4、5以外的其他数据{9  8}进行比较，8最小，8和9交换
排序结果：1  2  4  5  8  9
-------------------------------------------------------
```

**注**：每一趟排序获得最小数的方法：for循环进行比较，定义一个第三个变量temp，首先前两个数比较，把较小的数放在temp中，然后用temp再去跟剩下的数据比较，如果出现比temp小的数据，就用它代替temp中原有的数据。具体参照后面的代码示例，相信你在学排序之前已经学过for循环语句了，这样的话，这里理解起来就特别容易了。

**代码实现**

```
//选择排序
public class SelectionSort {
    public static void main(String[] args) {
        int[] arr={1,3,2,45,65,33,12};
        System.out.println("交换之前：");
        for(int num:arr){
            System.out.print(num+" ");
        }        
        //选择排序的优化
        for(int i = 0; i < arr.length - 1; i++) {// 做第i趟排序
            int k = i;
            for(int j = k + 1; j < arr.length; j++){// 选最小的记录
                if(arr[j] < arr[k]){ 
                    k = j; //记下目前找到的最小值所在的位置
                }
            }
            //在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换
            if(i != k){  //交换a[i]和a[k]
                int temp = arr[i];
                arr[i] = arr[k];
                arr[k] = temp;
            }    
        }
        System.out.println();
        System.out.println("交换后：");
        for(int num:arr){
            System.out.print(num+" ");
        }
    }

}
```

* 堆排序（选做）（完成leetcode上的返回滑动窗口中的最大值(239)，这是上一期第三天的任务进行保留（涉及队列可以对第二天进行整理复习））

* 编程实现 O(n) 时间复杂度内找到一组数据的第 K 大元素

#### 二分查找

* 实现一个有序数组的二分查找算法

**二分查找又称折半查找，它是一种效率较高的查找方法。**

1、折半查找的算法思想是将数列按有序化(递增或递减)排序，查找过程采用跳跃方式查找，即先以有序数列的中点位置为比较对象，如果要找的元素值小于该中点元素，则将待查序列缩小为左半部分，否则为右半部分。通过一次比较，将查找空间缩小一半。他可以明显缩小比较次数，提高查找效率。但是折半查找的先决条件是查找表中的数据元素必须有序。

```
折半查找的优点是：比较次数少，查找速度快，平均性能好；
缺点是：要求待查表为有序表，且插入困难。
```

因此，折半查找方法适用于不经常变动而查找频繁的有序列表。

2、二分法步骤描述

①首先确定整个查找区间的中间位置`mid=（left+right）/2`

②用待查关键字值key与中间位置的关键字值进行比较;

若相等，则查找成功;

若大于，则在右半个区域继续进行折半查找;

若小于，则在左半个区域继续进行折半查找;

③对确定的缩小区域再折半查找，重复上述步骤。

最后，得到结果：要么查找成功，要么查找失败。

折半查找的存储结构采用一维数组存放。

3、二分查找算法讨论

优点：`ASL<log2n`，即每经过一次查找，查找范围就缩小一半。经过`log2n`次比较就可以完成查找过程。

缺点：因要求有序，所以要求查找数列必须有序，而对所有数据元素按照大小排序是非常费时的操作。

另外，顺序存储结构的插入、删除操作不便利。

**代码实现**

```
package searching;
/**
 * 二分查找算法
 * @param a 有序数组
 * @param key 查找的元素
 * @return key的数组下标，没找到返回-1
 */
public class BinarySearch {
 
	public static void main(String[] args) {
		int[] a={3,5,11,17,21,23,28,30,32,50,64,78,81,95,101};
		System.out.println(binSearch(a,0,a.length-1,81));
		System.out.println(binSearch(a,81));
	}
 
	//二分查找 普通循环实现
	private static int binSearch(int[] a, int key) {
		// TODO Auto-generated method stub
		int mid=a.length/2;
		if (key==a[mid]) {
			return mid;
		}
		int start=0;
		int end=a.length-1;
		while(start<=end){
			mid=start+(end-start)/2;
			if (key==a[mid]) {
				return mid;
			}else if (key>a[mid]) {
				start=mid+1;
			}else {
				end=mid-1;
			}
		}
		return -1;
	}
 
	//二分查找递归实现
	private static int binSearch(int[] a, int start, int end, int key) {
		// TODO Auto-generated method stub
		int mid=start+(end-start)/2;
		if (a[mid]==key) {
			return mid;
		}
		if (start>=end) {
			return -1;
		}else if (key>a[mid]) {
			return binSearch(a, mid+1, end, key);
		}else if(key<a[mid]){
			return binSearch(a, start, mid-1, key);
		}
		return -1;
	}
}
```


* 实现模糊二分查找算法（比如大于等于给定值的第一个元素）

#### 参考链接

[Java排序算法（九）：归并排序](!https://blog.csdn.net/apei830/article/details/6591632)

[快速排序算法Java实现](!https://www.cnblogs.com/vanezkw/archive/2012/06/21/2557685.html)

[教你学习快速排序算法-程序员必备哦](!https://tryenough.com/arithmetic-quitsort)

[Java中的经典算法之冒泡排序(Bubble Sort)](https://www.cnblogs.com/shen-hua/p/5422676.html)

[有序数组的二分查找--Java实现](!https://blog.csdn.net/u014067137/article/details/80332251)

[LeetCode 专题：数组](https://www.liwei.party/2019/02/16/leetcode-tag/array/)

[有序数组的二分查找--Java实现](https://blog.csdn.net/u014067137/article/details/80332251)